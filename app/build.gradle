apply plugin: 'com.android.application'

android {
    compileSdkVersion rootProject.ext.android.compileSdkVersion
    buildToolsVersion rootProject.ext.android.buildToolsVersion

    defaultConfig {
        applicationId rootProject.ext.android.applicationId

        minSdkVersion rootProject.ext.android.minSdkVersion
        targetSdkVersion rootProject.ext.android.targetSdkVersion
        versionCode rootProject.ext.android.versionCode
        versionName rootProject.ext.android.versionName

        generatedDensities = []
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    aaptOptions {
        additionalParameters "--no-version-vectors"
    }

    lintOptions {
        // 移除lint检查的error
        abortOnError false
    }

    signingConfigs {
        debug {
            storeFile file(debugMKeystoreFile)
            storePassword debugMKeystorePassword
            keyAlias debugMKeyAlias
            keyPassword debugMKeyPassword
        }
        release {
            storeFile file(releaseMKeystoreFile)
            storePassword releaseMKeystorePassword
            keyAlias releaseMKeyAlias
            keyPassword releaseMKeyPassword
        }
    }

    buildTypes {
        debug {
            signingConfig signingConfigs.debug
            minifyEnabled false
            shrinkResources false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }

        release {
            signingConfig signingConfigs.release
            minifyEnabled true
            shrinkResources false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

}

dependencies {
    testCompile rootProject.ext.dependencies["junit"]
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile project(':libframework')
    compile project(':libapi')
    compile project(':libcustomview')
    compile project(':libmedia')
}

def buildTime() {
    return new Date().format("yyyy.MM.dd_HH.mm.ss")
}

android.applicationVariants.all { variant ->

    // 开始构建当前变体的即时时间
    def currentTime = buildTime()

    variant.outputs.each { output ->
        println "**************************************"
        println "currentTime: ${currentTime}"
        println "variant: ${output.name}"
        println "buildType: ${variant.buildType.name}"
        println "flavor: ${variant.flavorName}"
        println "manifest:  ${output.processResources.manifestFile}"
        println "**************************************"

        //将生成的apk文件保存至根目录的_apk文件下
        def outputFile = output.outputFile
        if (outputFile != null && outputFile.name.endsWith('.apk')) {

            deleteDirectory("${projectDir}/../_apk/${variant.buildType.name}")

            File outputDirectory = new File("${projectDir}/../_apk");
            def apkName = "${variant.buildType.name}/app-${output.name}-V${frameworkVersion}-#${buildNumber}-${currentTime}.apk"
            output.outputFile = new File(outputDirectory, apkName)
        }

        // 如果开启混淆,则保留混淆的映射关系文件,方便release进行调试
        if (variant.getBuildType().isMinifyEnabled()) {
            variant.assemble.doLast {
                copy {
                    from variant.mappingFile
                    into "${projectDir}/../_mappings"
                    rename { String fileName ->
                        "mapping-${output.name}-V${frameworkVersion}-#${buildNumber}-${currentTime}.txt"
                    }
                }
                deleteFile(variant.mappingFile.getPath())
            }
        }
    }
}





import java.io.File

/**
 * 删除目录（文件夹）以及目录下的文件
 * @param   sPath 被删除目录的文件路径
 * @return  目录删除成功返回true，否则返回false
 */
def deleteDirectory(String sPath) {

    //如果sPath不以文件分隔符结尾，自动添加文件分隔符
    if (!sPath.endsWith(File.separator)) {
        sPath = sPath + File.separator;
    }
    File dirFile = new File(sPath);
    //如果dir对应的文件不存在，或者不是一个目录，则退出
    if (!dirFile.exists() || !dirFile.isDirectory()) {
        return false;
    }
    boolean flag = true;
    //删除文件夹下的所有文件(包括子目录)
    File[] files = dirFile.listFiles();
    for (int i = 0; i < files.length; i++) {
        //删除子文件
        if (files[i].isFile()) {
            flag = deleteFile(files[i].getAbsolutePath());
            if (!flag) break;
        } //删除子目录
        else {
            flag = deleteDirectory(files[i].getAbsolutePath());
            if (!flag) break;
        }
    }
    if (!flag) return false;
    //删除当前目录
    if (dirFile.delete()) {
        return true;
    } else {
        return false;
    }
}

/**
 * 删除单个文件
 * @param   sPath    被删除文件的文件名
 * @return 单个文件删除成功返回true，否则返回false
 */
def deleteFile(String sPath) {
    boolean flag = false;
    File file = new File(sPath);
    // 路径为文件且不为空则进行删除
    if (file.isFile() && file.exists()) {
        file.delete();
        flag = true;
    }
    return flag;
}

